use std::str::FromStr;
use expression::{Expression, BinaryExpressionData, UnaryExpressionData, VariableMappingData, UnsignedBitVectorData, SignedBitVectorData, BinaryOperator, UnaryOperator};
grammar;

pub E1: Expression = {
	<left: E1> <op: BOP> <right: E2> => Expression::BinaryExpression( BinaryExpressionData { op: op, left: Box::new(left), right: Box::new(right) } ),
	E2,
};

pub E2: Expression = {
	<op: UOP> <e: E2> => Expression::UnaryExpression( UnaryExpressionData { op: op, e: Box::new(e) } ),
	E3,
};

pub E3: Expression = {
	"true" => Expression::BooleanLiteral(true),
	"false" => Expression::BooleanLiteral(false),
	<i:r"[-][0-9]+"> => Expression::SignedBitVector( SignedBitVectorData { size: 64, value: i64::from_str(i).unwrap() } ),
	<i:r"[0-9]+"> => Expression::UnsignedBitVector( UnsignedBitVectorData { size: 64, value: u64::from_str(i).unwrap() } ),
	<v:r"_[a-zA-Z0-9_]+"> ":" "bool" => Expression::VariableMapping( VariableMappingData { name: v.to_string(), var_type: "bool".to_string() } ),
	<v:r"[a-zA-Z][a-zA-Z0-9_]*"> ":" "bool" =>  Expression::VariableMapping( VariableMappingData { name: v.to_string(), var_type: "bool".to_string() } ),
	<v:r"_[a-zA-Z0-9_]+"> ":" "int" => Expression::VariableMapping( VariableMappingData { name: v.to_string(), var_type: "int".to_string() } ),
	<v:r"[a-zA-Z][a-zA-Z0-9_]*"> ":" "int" =>  Expression::VariableMapping( VariableMappingData { name: v.to_string(), var_type: "int".to_string() } ),
	"(" <e: E1> ")" => e,
};

pub UOP: UnaryOperator = {
	"-" => UnaryOperator::Negation,
	"!" => UnaryOperator::BitwiseNot,
	"NOT" => UnaryOperator::Not,
};

pub BOP: BinaryOperator = {
	"+" => BinaryOperator::Addition,
	"-" => BinaryOperator::Subtraction,
	"*" => BinaryOperator::Multiplication,
	"/" => BinaryOperator::Division,
	"%" => BinaryOperator::Modulo,
	"&" => BinaryOperator::BitwiseAnd,
	"|" => BinaryOperator::BitwiseOr,
	"^" => BinaryOperator::BitwiseXor,
	"<<" => BinaryOperator::BitwiseLeftShift,
	">>" => BinaryOperator::BitwiseRightShift,
	"<" => BinaryOperator::LessThan,
	"<=" => BinaryOperator::LessThanOrEqual,
	">" => BinaryOperator::GreaterThan,
	">=" => BinaryOperator::GreaterThanOrEqual,
	"==" => BinaryOperator::Equal,
	"!=" => BinaryOperator::NotEqual,
	"&&" => BinaryOperator::And,
	"||" => BinaryOperator::Or,
	"AND" => BinaryOperator::And,
	"OR" => BinaryOperator::Or,
	"XOR" => BinaryOperator::Xor,
	"IMPLICATION" => BinaryOperator::Implication,
	"BIIMPLICATION" => BinaryOperator::BiImplication,
};
